<!DOCTYPE html>
<html lang="en-US">
 <head>
  <meta http-equiv="Content-type" content="text/html;charset=utf-8" />
  <meta name="author" content="PLP Consulting" />
  <title>A tree of ReactiveX Observable operators</title>
  <style>
   body { background: #003; 
          font-family: Verdana,Arial,sans-serif; }
   div#main { background: #ffc;
              margin: 2em;
              padding: 25px;
              border-radius: 10px;
              border-style: solid;
              border-width: 5px;
              border-color: #ca0; }
   h1 { border-radius: 10px;
        border-style: solid;
        border-color: #ca0;
        border-width: 5px;
        background: #fff;
        font-size: 2em;
        margin: -30px;
        margin-bottom: 1em;
        padding-left: 1em; }

   dl { margin-top: 0;
        margin-bottom: 0;
        margin-left: 1.5em; }
   dl#outer>dt { font-weight: bold;
                 margin-right: -1.5em; }
   dt { font-weight: normal;
        margin-right: -1.5em; }
   dl > dt::before { content: "â€¦"; }
   dl#outer > dt::before { content: ""; }
   dd::before { content: ": "; }
   dd.sub::before { content: ""; }

   dt { float: left; clear: left; }
   dd { float: left;
        margin-start: 0;
        -webkit-margin-start: 0;
        margin-left: 1.5em; }
   dd.sub { float: none;
            margin-left: 0; }
   hr { clear: both; }

/**
   dl dt, dl dd { background: #fff; }
   dl dl dt, dl dl dd { background: #eef; }
   dl dl dl dt, dl dl dl dd { background: #ffe; }
   dl dl dl dl dt, dl dl dl dl dd { background: #efe; }
   dl dl dl dl dl dt, dl dl dl dl dl dd { background: #fef; }
   dl dl dl dl dl dl dt, dl dl dl dl dl dl dd { background: #fee; }
**/
  </style>
 </head>
 <body><div id="main">
  <h1>A tree of ReactiveX Observable operators</h1>
  <p>
   This tree can help you find the ReactiveX Observable operator you&#8217;re looking for.
  </p>
<div>
<dl id="outer">
 <dt>I want to create a new Observable</dt>
  <dd class="sub"><dl>
   <dt>that emits a particular item</dt>
    <dd><a href="just.html">Just</a></dd>
    <dd class="sub"><dl>
     <dt>that was returned from a function called at subscribe-time</dt>
      <dd><a href="start.html">Start</a></dd>
      <dd class="sub"><dl>
       <dt>anew for each subscriber</dt>
        <dd><a href="toAsync.html">ToAsync</a></dd>
      </dl></dd>
     <dt>that was returned from an <code>Action</code>, <code>Callable</code>, <code>Runnable</code>, or something of that sort, called at subscribe-time</dt>
      <dd><a href="from.html">From</a></dd>
     <dt>after a specified delay</dt>
      <dd><a href="timer.html">Timer</a></dd>
     </dl></dd>
   <dt>that pulls its emissions from a particular <code>Array</code>, <code>Iterable</code>, or something like that</dt>
    <dd><a href="from.html">From</a></dd>
   <dt>by retrieving it from a Future</dt>
    <dd><a href="start.html">Start</a></dd>
   <dt>that obtains its sequence from a Future</dt>
    <dd><a href="from.html">From</a></dd>
   <dt>that obtains its sequence from an <code>Action</code> called periodically</dt>
    <dd><a href="runAsync.html">RunAsync</a></dd>
   <dt>that emits a sequence of items repeatedly</dt>
    <dd><a href="repeat.html">Repeat</a></dd>
    <dd class="sub"><dl>
     <dt>as long as a predicate remains true</dt>
      <dd><a href="whileDo.html">WhileDo</a></dd>
    </dl></dd>
   <dt>from scratch, with custom logic</dt>
    <dd><a href="create.html">Create</a></dd>
   <dt>for each observer that subscribes</dt>
    <dd><a href="defer.html">Defer</a></dd>
   <dt>that emits a sequence of integers</dt>
    <dd><a href="range.html">Range</a></dd>
    <dd class="sub"><dl>
     <dt>at particular intervals of time</dt>
      <dd><a href="interval.html">Interval</a></dd>
      <dd class="sub"><dl>
       <dt>after a specified delay</dt>
       <dd><a href="timer.html">Timer</a></dd>
      </dl></dd>
    </dl></dd>
   <dt>that completes without emitting items</dt>
    <dd><a href="empty.html">Empty</a></dd>
   <dt>that does nothing at all</dt>
    <dd><a href="never.html">Never</a></dd>
  </dl></dd>

 <dt>I want to create an Observable by combining other Observables</dt>
  <dd class="sub"><dl>
   <dt>and emitting all of the items from all of the Observables in whatever order they are received</dt>
    <dd><a href="merge.html">Merge</a></dd>
   <dt>and emitting all of the items from all of the Observables, one Observable at a time</dt>
    <dd><a href="concat.html">Concat</a></dd>
   <dt>by combining the items from two or more Observables sequentially to come up with new items to emit</dt>
    <dd class="sub"><dl>
     <dt>whenever <em>each</em> of the Observables has emitted a new item</dt>
      <dd><a href="zip.html">Zip</a></dd>
     <dt>whenever <em>any</em> of the Observables has emitted a new item</dt>
      <dd><a href="combineLatest.html">CombineLatest</a></dd>
     <dt>whenever an item is emitted by one Observable in a window defined by an item emitted by another</dt>
      <dd><a href="join.html">Join</a></dd>
      <dd class="sub"><dl>
       <dt>based on an Observable that emits all items that have fallen in such a window</dt>
        <dd><a href="groupJoin.html">GroupJoin</a></dd>
      </dl></dd>
     <dt>by means of <code>Pattern</code> and <code>Plan</code> intermediaries</dt>
      <dd><a href="and-then-when.html">And/Then/When</a></dd>
    </dl></dd>
   <dt>and emitting the items from only the most-recently emitted of those Observables</dt>
    <dd><a href="switch.html">Switch</a></dd>
  </dl></dd>

 <dt>I want emit the items from an Observable after transforming them</dt>
  <dd class="sub"><dl>
   <dt>one at a time with a function</dt>
    <dd><a href="map.html">Map</a></dd>
   <dt>by emitting all of the items emitted by corresponding Observables</dt>
    <dd><a href="flatMap.html">FlatMap</a></dd>
    <dd class="sub"><dl>
     <dt>one Observable at a time, in the order they are emitted</dt>
      <dd><a href="concatMap.html">ConcatMap</a></dd>
    </dl></dd>
   <dt>based on all of the items that preceded them</dt>
    <dd><a href="scan.html">Scan</a></dd>
   <dt>by attaching a timestamp to them</dt>
    <dd><a href="timestamp.html">Timestamp</a></dd>
   <dt>into an indicator of the amount of time that lapsed before the emission of the item</dt>
    <dd><a href="timeinterval.html">TimeInterval</a></dd>
  </dl></dd>

 <dt>I want to shift the items emitted by an Observable forward in time before reemitting them</dt>
  <dd><a href="delay.html">Delay</a></dd>

 <dt>I want to transform items <em>and</em> notifications from an Observable into items and reemit them</dt>
  <dd class="sub"><dl>
   <dt>by wrapping them in <code>Notification</code> objects</dt>
    <dd><a href="materialize.html">Materialize</a></dd>
    <dd class="sub"><dl>
     <dt>which I can then unwrap again with</dt>
      <dd><a href="dematerialize.html">Dematerialize</a></dd>
    </dl></dd>
  </dl></dd>

 <dt>I want to ignore all items emitted by an Observable and only pass along its completed/error notification</dt>
  <dd><a href="ignoreElements.html">IgnoreElements</a></dd>

 <dt>I want to mirror an Observable but prefix items to its sequence</dt>
  <dd><a href="startWith.html">StartWith</a></dd>
  <dd class="sub"><dl>
   <dt>only if its sequence is empty</dt>
    <dd><a href="defaultIfEmpty.html">DefaultIfEmpty</a></dd>
  </dl></dd>

 <dt>I want to collect items from an Observable and reemit them as buffers of items</dt>
  <dd><a href="buffer.html">Buffer</a></dd>
  <dd class="sub"><dl>
   <dt>containing only the last items emitted</dt>
    <dd><a href="takeLast.html">TakeLast</a></dd>
  </dl></dd>

 <dt>I want to split one Observable into multiple Observables</dt>
  <dd><a href="window.html">Window</a></dd>
  <dd class="sub"><dl>
   <dt>so that similar items end up on the same Observable</dt>
    <dd><a href="groupBy.html">GroupBy</a></dd>
  </dl></dd>

 <dt>I want to retrieve a particular item emitted by an Observable:</dt>
  <dd class="sub"><dl>
   <dt>the last item emitted before it completed</dt>
    <dd><a href="last.html">Last</a></dd>
   <dt>the sole item it emitted</dt>
    <dd><a href="single.html">Single</a></dd>
   <dt>the first item it emitted</dt>
    <dd><a href="first.html">First</a></dd>
  </dl></dd>

 <dt>I want to reemit only certain items from an Observable</dt>
  <dd class="sub"><dl>
   <dt>by filtering out those that do not match some predicate</dt>
    <dd><a href="filter.html">Filter</a></dd>
   <dt>that is, only the first item</dt>
    <dd><a href="first.html">First</a></dd>
   <dt>that is, only the first item<em>s</em></dt>
    <dd><a href="take.html">Take</a></dd>
   <dt>that is, only the last item</dt>
    <dd><a href="last.html">Last</a></dd>
   <dt>that is, only item <i>n</i></dt>
    <dd><a href="elementAt.html">ElementAt</a></dd>
   <dt>that is, only those items after the first items</dt>
    <dd class="sub"><dl>
     <dt>that is, after the first <i>n</i> items</dt>
      <dd><a href="skip.html">Skip</a></dd>
     <dt>that is, until one of those items matches a predicate</dt>
      <dd><a href="skipWhile.html">SkipWhile</a></dd>
     <dt>that is, after an initial period of time</dt>
      <dd><a href="skip.html">Skip</a></dd>
     <dt>that is, after a second Observable emits an item</dt>
      <dd><a href="skipUntil.html">SkipUntil</a></dd>
    </dl></dd>
   <dt>that is, those items except the last items</dt>
    <dd class="sub"><dl>
     <dt>that is, except the last <i>n</i> items</dt>
      <dd><a href="skipLast.html">SkipLast</a></dd>
     <dt>that is, until one of those items matches a predicate</dt>
      <dd><a href="takeWhile.html">TakeWhile</a></dd>
     <dt>that is, except items emitted during a period of time before the source completes</dt>
      <dd><a href="skipLast.html">SkipLast</a></dd>
     <dt>that is, except items emitted after a second Observable emits an item</dt>
      <dd><a href="takeUntil.html">TakeUntil</a></dd>
    </dl></dd>
   <dt>by sampling the Observable periodically</dt>
    <dd><a href="sample.html">Sample</a></dd>
   <dt>by only emitting items that are not followed by other items within some duration</dt>
    <dd><a href="throttle.html">Throttle</a></dd>
   <dt>by suppressing items that are duplicates of already-emitted items</dt>
    <dd><a href="distinct.html">Distinct</a></dd>
    <dd class="sub"><dl>
     <dt>if they immediately follow the item they are duplicates of</dt>
      <dd><a href="distinct.html">DistinctUntilChanged</a></dd>
    </dl></dd>
   <dt>by delaying my subscription to it for some time after it begins emitting items</dt>
    <dd><a href="delay.html">DelaySubscription</a></dd>
  </dl></dd>

 <dt>I want to reemit items from an Observable only on condition that it was the first of a collection of Observables to emit an item</dt>
  <dd><a href="amb.html">Amb</a></dd>

 <dt>I want to evaluate the entire sequence of items emitted by an Observable</dt>
  <dd class="sub"><dl>
   <dt>and emit a single boolean indicating if <em>all</em> of the items pass some test</dt>
    <dd><a href="all.html">All</a></dd>
   <dt>and emit a single boolean indicating if the Observable emitted <em>any</em> item (that passes some test)</dt>
    <dd><a href="contains.html">Contains</a></dd>
   <dt>and emit a single boolean indicating if the Observable emitted <em>no</em> items</dt>
    <dd><a href="isEmpty.html">IsEmpty</a></dd>
   <dt>and emit a single boolean indicating if the sequence is identical to one emitted by a second Observable</dt>
    <dd><a href="sequenceEqual.html">SequenceEqual</a></dd>
   <dt>and emit the average of all of their values</dt>
    <dd><a href="average.html">Average</a></dd>
   <dt>and emit the sum of all of their values</dt>
    <dd><a href="sum.html">Sum</a></dd>
   <dt>and emit a number indicating how many items were in the sequence</dt>
    <dd><a href="count.html">Count</a></dd>
   <dt>and emit the item with the maximum value</dt>
    <dd><a href="max.html">Max</a></dd>
   <dt>and emit the item with the minimum value</dt>
    <dd><a href="min.html">Min</a></dd>
   <dt>by applying an aggregation function to each item in turn and emitting the result</dt>
    <dd><a href="scan.html">Scan</a></dd>
  </dl></dd>

 <dt>I want to convert the entire sequence of items emitted by an Observable into some other data structure</dt>
  <dd><a href="to.html">To</a></dd>

 <dt>I want an operator to operate on a particular Scheduler</dt>
  <dd><a href="observeOn.html">SubscribeOn</a></dd>
  <dd class="sub"><dl>
   <dt>when it notifies observers</dt>
    <dd><a href="observeOn.html">ObserveOn</a></dd>
  </dl></dd>

 <dt>I want an Observable to invoke a particular action when certain events occur</dt>
  <dd><a href="do.html">Do</a></dd>

 <dt>I want an Observable that will notify observers of an error</dt>
  <dd><a href="throw.html">Throw</a></dd>
  <dd class="sub"><dl>
   <dt>if a specified period of time elapses without it emitting an item</dt>
    <dd><a href="timeout.html">Timeout</a></dd>
  </dl></dd>

 <dt>I want an Observable to recover gracefully</dt>
  <dd class="sub"><dl>
   <dt>from a timeout by switching to a backup Observable</dt>
    <dd><a href="timeout.html">Timeout</a></dd>
   <dt>from an upstream error notification</dt>
    <dd><a href="catch.html">Catch</a></dd>
    <dd class="sub"><dl>
     <dt>by attempting to resubscribe to the upstream Observable</dt>
      <dd><a href="retry.html">Retry</a></dd>
    </dl></dd>
   <dt>from being potentially unserialized or otherwise poorly-behaved</dt>
    <dd><a href="serialize.html">Serialize</a></dd>
  </dl></dd>

 <dt>I want to create a resource that has the same lifespan as the Observable</dt>
  <dd><a href="using.html">Using</a></dd>

 <dt>I want to subscribe to an Observable and receive a <code>Future</code> that blocks until the Observable completes</dt>
  <dd><a href="start.html">Start</a></dd>

 <dt>I want an Observable that does not start emitting items to subscribers until asked</dt>
  <dd><a href="publish.html">Publish</a></dd>
  <dd class="sub"><dl>
   <dt>and then only emits the last item in its sequence</dt>
    <dd><a href="publishLast.html">PublishLast</a></dd>
   <dt>and then emits the complete sequence, even to those who subscribe after the sequence has begun</dt>
    <dd><a href="replay.html">Replay</a></dd>
   <dt>but I want it to go away once all of its subscribers unsubscribe</dt>
    <dd><a href="refCount.html">RefCount</a></dd>
   <dt>and then I want to ask it to start</dt>
    <dd><a href="connect">Connect</a></dd>
  </dl></dd>

</dl>
</div>
<hr />
<p>
 This page was inspired by the RxJS tables (<a href="https://github.com/trxcllnt/RxJS/blob/master/doc/static-operators.md">static</a> and <a href="https://github.com/trxcllnt/RxJS/blob/master/doc/instance-operators.md">instance</a>) created by Paul Taylor.
</p>
 </div></body>
</html>
