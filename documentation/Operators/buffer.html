<!DOCTYPE html>
<html lang="en-us">
 <head>
  <meta charset="utf-8" />
  <title>Buffer</title>
  <link href="jquery-ui-1.11.2.custom/jquery-ui.css" rel="stylesheet" />
  <link href="CSS/operators.css" rel="stylesheet" />
 </head>
 <body>
  <div id="operator">
   <h1 id="canonical">Buffer</h1>
   <h2 id="summary">periodically gather items emitted by an Observable into bundles and emit these
    bundles rather than emitting the items one at a time</h2>
   <figure>
    <img src="IMAGES/Buffer.png" width="640" height="320" alt="Buffer" />
   </figure>
   <p>
    The <span class="operator">Buffer</span> operator transforms an Observable that emits items into
    an Observable that emits buffered collections of those items. There are a number of variants in
    the various language-specific implementations of <span class="operator">Buffer</span> that
    differ in how they choose which items go in which buffers.
   </p><p>
    Note that if the source Observable issues an <code>onError</code> notification,
    <span class="operator">Buffer</span> will pass on this notification immediately without first
    emitting the buffer it is in the process of assembling, even if that buffer contains items that
    were emitted by the source Observable before it issued the error notification.
   </p>
   <h3>See also:</h3>
   <ul>
    <li><span class="operator">Window</span> &mdash; similar to <span class="operator">Buffer</span>
        but collects items into Observables rather than into data structures before reemitting
        them</li>
   </ul>
   <h2>Language-Specific Information:</h2>
   <div id="accordion">

<!-- RxCpp ==================================================================================== -->
    <h3>RxCpp</h3><div id="RxCpp">
     <p>
      RxCpp implements two variants of <span class="operator">buffer</span>:
     </p>
     <figure class="variant">
      <img src="IMAGES/buffer3.png" width="640" height="320" alt="buffer(count)" />
      <figcaption>
       <p><code>buffer(count)</code> emits non-overlapping buffers in the form of
          <code>vector</code>s, each of which contains at most <code>count</code> items from the
          source Observable (the final emitted <code>vector</code> may have fewer than
          <code>count</code> items).</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer4.png" width="640" height="320" alt="buffer(count,skip)" />
      <figcaption>
       <p><code>buffer(count,&#8239;skip)</code> creates a new buffer starting with the first
          emitted item from the source Observable, and every <code>skip</code> items thereafter, and
          fills each buffer with <code>count</code> items: the initial item and <code>count-1</code>
          subsequent ones. It emits these buffers as <code>vector</code>s. Depending on the values
          of <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers
          may contain the same item), or they may have gaps (where items emitted by the source
          Observable are not represented in any buffer).</p>
      </figcaption>
     </figure>
    </div>

<!-- RxGroovy ================================================================================= -->
    <h3>RxGroovy</h3><div id="RxGroovy">
     <p>
      The RxGroovy implementation of <span class="operator">buffer</span> mirrors that of RxJava.
     </p>
    </div>

<!-- RxJava =================================================================================== -->
    <h3>RxJava</h3><div id="RxJava">
     <p>
      In RxJava there are several variants of <span class="operator">buffer</span>:
     </p>
     <figure class="variant">
      <img src="IMAGES/buffer3.png" width="640" height="320" alt="buffer(count)" />
      <figcaption>
       <p><code>buffer(count)</code> emits non-overlapping buffers in the form of
          <code>List</code>s, each of which contains at most <code>count</code> items from the
          source Observable (the final emitted <code>List</code> may have fewer than
          <code>count</code> items).</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer4.png" width="640" height="320" alt="buffer(count,skip)" />
      <figcaption>
       <p><code>buffer(count,&#8239;skip)</code> creates a new buffer starting with the first
          emitted item from the source Observable, and every <code>skip</code> items thereafter, and
          fills each buffer with <code>count</code> items: the initial item and <code>count-1</code>
          subsequent ones. It emits these buffers as <code>List</code>s. Depending on the values of
          <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may
          contain the same item), or they may have gaps (where items emitted by the source
          Observable are not represented in any buffer).</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer1.png" width="640" height="395" alt="buffer(bufferClosingSelector)" />
      <figcaption>
       <p>When it subscribes to the source Observable, <code>buffer(bufferClosingSelector)</code>
          begins to collect its emissions into a <code>List</code>, and it also calls
          <code>bufferClosingSelector</code> to generate a second Observable. When this second
          Observable emits an <code>TClosing</code> object, <code>buffer</code> emits the current
          <code>List</code> and repeats this process: beginning a new <code>List</code> and calling
          <code>bufferClosingSelector</code> to create a new Observable to monitor. It will do this
          until the source Observable terminates.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer8.png" width="640" height="395" alt="buffer(boundary)" />
      <figcaption>
       <p><code>buffer(boundary)</code> monitors an Observable, <code>boundary</code>. Each time
          that Observable emits an item, it creates a new <code>List</code> to begin collecting
          items emitted by the source Observable and emits the previous <code>List</code>.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer2.png" width="640" height="470" alt="buffer(bufferOpenings,bufferClosingSelector)" />
      <figcaption>
       <p><code>buffer(bufferOpenings,&#8239;bufferClosingSelector)</code> monitors an Observable,
          <code>bufferOpenings</code>, that emits <code>BufferOpening</code> objects. Each time it
          observes such an emitted item, it creates a new <code>List</code> to begin collecting
          items emitted by the source Observable and it passes the <code>bufferOpenings</code>
          Observable into the <code>closingSelector</code> function. That function returns an
          Observable. <code>buffer</code> monitors that Observable and when it detects an emitted
          item from it, it closes the <code>List</code> and emits it as its own emission.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer5.png" width="640" height="320" alt="buffer(timespan,unit)" />
      <figcaption>
       <p><code>buffer(timespan,&#8239;unit)</code> emits a new <code>List</code> of items
          periodically, every <code>timespan</code> amount of time, containing all items emitted by
          the source Observable since the previous bundle emission or, in the case of the first
          bundle, since the subscription to the source Observable. There is also a version of this
          variant of the operator that takes a <code>Scheduler</code> as a parameter and uses it to
          govern the timespan; by default this variant uses the <code>computation</code>
          scheduler.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer6.png" width="640" height="320" alt="buffer(timespan,unit,count)" />
      <figcaption>
       <p><code>buffer(timespan,&#8239;unit,&#8239;count)</code> emits a new <code>List</code> of
          items for every <code>count</code> items emitted by the source Observable, or, if
          <code>timespan</code> has elapsed since its last bundle emission, it emits a bundle of
          however many items the source Observable has emitted in that span, even if this is fewer
          than <code>count</code>. There is also a version of this variant of the operator that
          takes a <code>Scheduler</code> as a parameter and uses it to govern the timespan; by
          default this variant uses the <code>computation</code> scheduler.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer7.png" width="640" height="320" alt="buffer(timespan,timeshift,unit)" />
      <figcaption>
       <p><code>buffer(timespan,&#8239;timeshift,&#8239;unit)</code> creates a new <code>List</code>
          of items every <code>timeshift</code> period of time, and fills this bundle with every
          item emitted by the source Observable from that time until <code>timespan</code> time has
          passed since the bundle&#8217;s creation, before emitting this <code>List</code> as its
          own emission. If <code>timespan</code> is longer than <code>timeshift</code>, the emitted
          bundles will represent time periods that overlap and so they may contain duplicate items.
          There is also a version of this variant of the operator that takes a
          <code>Scheduler</code> as a parameter and uses it to govern the timespan; by default this
          variant uses the <code>computation</code> scheduler.</p>
      </figcaption>
     </figure>
    </div>

<!-- RxJS ===================================================================================== -->
    <h3>RxJS</h3><div id="RxJS">
     <p>
      RxJS has four <span class="operator">Buffer</span> operators &mdash; <code>buffer</code>,
      <code>bufferWithCount</code>, <code>bufferWithTime</code>, and
      <code>bufferWithTimeOrCount</code> &mdash; each of which has variants that have different
      ways of governing which source Observable items are emitted as part of which buffers.
     </p>
     <figure class="variant">
      <img src="IMAGES/buffer8.png" width="640" height="395" alt="buffer(bufferBoundaries)" />
      <figcaption>
       <p><code>buffer(bufferBoundaries)</code> monitors an Observable,
          <code>bufferBoundaries</code>. Each time that Observable emits an item, it creates a new
          collection to begin collecting items emitted by the source Observable and emits the
          previous collection.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer1.png" width="640" height="395" alt="buffer(bufferClosingSelector)" />
      <figcaption>
       <p>When it subscribes to the source Observable, <code>buffer(bufferClosingSelector)</code>
          begins to collect its emissions into a collection, and it also calls
          <code>bufferClosingSelector</code> to generate a second Observable. When this second
          Observable emits an item, <code>buffer</code> emits the current collection and repeats
          this process: beginning a new collection and calling <code>bufferClosingSelector</code>
          to create a new Observable to monitor. It will do this until the source Observable
          terminates.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer2.png" width="640" height="470" alt="buffer(bufferOpenings,bufferClosingSelector)" />
      <figcaption>
       <p><code>buffer(bufferOpenings,&#8239;bufferClosingSelector)</code> monitors an Observable,
          <code>bufferOpenings</code>, that emits <code>BufferOpening</code> objects. Each time it
          observes such an emitted item, it creates a new collection to begin collecting items
          emitted by the source Observable and it passes the <code>bufferOpenings</code>
          Observable into the <code>bufferClosingSelector</code> function. That function returns an
          Observable. <code>buffer</code> monitors that Observable and when it detects an emitted
          item from it, it emits the current collection and begins a new one.</p>
      </figcaption>
     </figure>
     <p>
      <code>buffer</code> is found in each of the following distributions:
     </p>
     <ul>
      <li><code>rx.all.js</code></li>
      <li><code>rx.all.compat.js</code></li>
      <li><code>rx.coincidence.js</code></li>
     </ul>
     <p>
      <code>buffer</code> requires one of the following distributions:
     </p>
     <ul>
      <li><code>rx.js</code></li>
      <li><code>rx.compat.js</code></li>
      <li><code>rx.lite.js</code></li>
      <li><code>rx.lite.compat.js</code></li>
     </ul>
     <figure class="variant">
      <img src="IMAGES/bufferWithCount3.png" width="640" height="320" alt="bufferWithCount(count)" />
      <figcaption>
       <p><code>bufferWithCount(count)</code> emits non-overlapping buffers, each of which contains
          at most <code>count</code> items from the source Observable (the final emitted buffer may
          contain fewer than <code>count</code> items).</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/bufferWithCount4.png" width="640" height="320" alt="bufferWithCount(count,skip)" />
      <figcaption>
       <p><code>bufferWithCount(count,&#8239;skip)</code> creates a new buffer starting with the
          first emitted item from the source Observable, and a new one for every <code>skip</code>
          items thereafter, and fills each buffer with <code>count</code> items: the initial item
          and <code>count-1</code> subsequent ones, emitting each buffer when it is complete.
          Depending on the values of <code>count</code> and <code>skip</code> these buffers may
          overlap (multiple buffers may contain the same item), or they may have gaps (where items
          emitted by the source Observable are not represented in any buffer).</p>
      </figcaption>
     </figure>
     <p>
      <code>bufferWithCount</code> is found in each of the following distributions:
     </p>
     <ul>
      <li><code>rx.js</code></li>
      <li><code>rx.compat.js</code></li>
      <li><code>rx.all.js</code></li>
      <li><code>rx.all.compat.js</code></li>
      <li><code>rx.lite.extras.js</code></li>
     </ul>
     <figure class="variant">
      <img src="IMAGES/bufferWithTime5.png" width="640" height="340" alt="bufferWithTime(timeSpan)" />
      <figcaption>
       <p><code>bufferWithTime(timeSpan)</code> emits a new collection of items periodically, every
          <code>timeSpan</code> milliseconds, containing all items emitted by the source Observable
          since the previous bundle emission or, in the case of the first bundle, since the
          subscription to the source Observable. There is also a version of this variant of the
          operator that takes a <code>Scheduler</code> as a parameter and uses it to govern the
          timespan; by default this variant uses the <code>timeout</code> scheduler.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/bufferWithTime7.png" width="640" height="320" alt="bufferWithTime(timeSpan,timeShift)" />
      <figcaption>
       <p><code>bufferWithTime(timeSpan,&#8239;timeShift)</code> creates a new collection of items
          every <code>timeShift</code> milliseconds, and fills this bundle with every item emitted
          by the source Observable from that time until <code>timeSpan</code> milliseconds has
          passed since the collection&#8217;s creation, before emitting this collection as its own
          emission. If <code>timeSpan</code> is longer than <code>timeShift</code>, the emitted
          bundles will represent time periods that overlap and so they may contain duplicate items.
          There is also a version of this variant of the operator that takes a
          <code>Scheduler</code> as a parameter and uses it to govern the timespan; by default this
          variant uses the <code>computation</code> scheduler.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/bufferWithTimeOrCount6.png" width="640" height="340" alt="bufferWithTimeOrCount(timeSpan,count)" />
      <figcaption>
       <p><code>bufferWithTimeOrCount(timeSpan,&#8239;count)</code> emits a new collection of items
          for every <code>count</code> items emitted by the source Observable, or, if
          <code>timeSpan</code> milliseconds have elapsed since its last collection emission, it
          emits a collection of however many items the source Observable has emitted in that span,
          even if this is fewer than <code>count</code>. There is also a version of this variant of
          the operator that takes a <code>Scheduler</code> as a parameter and uses it to govern the
          timespan; by default this variant uses the <code>timeout</code> scheduler.</p>
      </figcaption>
     </figure>
     <p>
      <code>bufferWithTime</code> and <code>bufferWithTimeOrCount</code> are found in each of the
      following distributions:
     </p>
     <ul>
      <li><code>rx.all.js</code></li>
      <li><code>rx.all.compat.js</code></li>
      <li><code>rx.time.js</code></li>
     </ul>
     <p>
      <code>bufferWithTime</code> and <code>bufferWithTimeOrCount</code> require one of the
      following distributions:
     </p>
     <ul>
      <li><code>rx.time.js</code> requires <code>rx.js</code> or <code>rx.compat.js</code></li>
      <li>otherwise: <code>rx.lite.js</code> or <code>rx.lite.compat.js</code></li>
     </ul>
    </div>

<!-- RxKotlin ================================================================================= -->
    <h3>RxKotlin</h3><div id="RxKotlin">
     <p>
      The RxKotlin implementation of <span class="operator">buffer</span> mirrors that of RxJava.
     </p>
    </div>

<!-- Rx.NET =================================================================================== -->
    <h3>Rx.NET</h3><div id="RxNET">
     <p>
      In Rx.NET there are several variants of <span class="operator">Buffer</span>. For each variety
      you can either pass in the source Observable as the first parameter, or you can call it as
      an instance method of the source Observable (in which case you can omit that parameter):
     </p>
     <figure class="variant">
      <img src="IMAGES/Buffer3.net.png" width="640" height="320" alt="Buffer(count)" />
      <figcaption>
       <p><code>Buffer(count)</code> emits non-overlapping buffers in the form of
          <code>IList</code>s, each of which contains at most <code>count</code> items from the
          source Observable (the final emitted <code>IList</code> may have fewer than
          <code>count</code> items).</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/Buffer4.net.png" width="640" height="320" alt="Buffer(count,skip)" />
      <figcaption>
       <p><code>Buffer(count,&#8239;skip)</code> creates a new buffer starting with the first
          emitted item from the source Observable, and every <code>skip</code> items thereafter, and
          fills each buffer with <code>count</code> items: the initial item and <code>count-1</code>
          subsequent ones. It emits these buffers as <code>IList</code>s. Depending on the values of
          <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may
          contain the same item), or they may have gaps (where items emitted by the source
          Observable are not represented in any buffer).</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/Buffer1.net.png" width="640" height="395" alt="Buffer(bufferClosingSelector)" />
      <figcaption>
       <p>When it subscribes to the source Observable, <code>Buffer(bufferClosingSelector)</code>
          begins to collect its emissions into an <code>IList</code>, and it also calls
          <code>bufferClosingSelector</code> to generate a second Observable. When this second
          Observable emits an <code>TBufferClosing</code> object, <code>Buffer</code> emits the
          current <code>IList</code> and repeats this process: beginning a new <code>IList</code>
          and calling <code>bufferClosingSelector</code> to create a new Observable to monitor. It
          will do this until the source Observable terminates.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/Buffer2.net.png" width="640" height="470" alt="Buffer(bufferOpenings,bufferClosingSelector)" />
      <figcaption>
       <p><code>Buffer(bufferOpenings,&#8239;bufferClosingSelector)</code> monitors an Observable,
          <code>BufferOpenings</code>, that emits <code>TBufferOpening</code> objects. Each time it
          observes such an emitted item, it creates a new <code>IList</code> to begin collecting
          items emitted by the source Observable and it passes the <code>TBufferOpening</code>
          object into the <code>bufferClosingSelector</code> function. That function returns an
          Observable. <code>Buffer</code> monitors that Observable and when it detects an emitted
          item from it, it closes the <code>IList</code> and emits it as its own emission.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/Buffer5.net.png" width="640" height="340" alt="Buffer(timeSpan)" />
      <figcaption>
       <p><code>Buffer(timeSpan)</code> emits a new <code>IList</code> of items periodically, every
          <code>timeSpan</code> amount of time, containing all items emitted by the source
          Observable since the previous bundle emission or, in the case of the first list, since
          the subscription to the source Observable. There is also a version of this variant of the
          operator that takes an <code>IScheduler</code> as a parameter and uses it to
          govern the timespan.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/Buffer6.net.png" width="640" height="340" alt="Buffer(timeSpan,count)" />
      <figcaption>
       <p><code>Buffer(timeSpan,&#8239;count)</code> emits a new <code>IList</code> of items for
          every <code>count</code> items emitted by the source Observable, or, if
          <code>timeSpan</code> has elapsed since its last list emission, it emits a list of
          however many items the source Observable has emitted in that span, even if this is fewer
          than <code>count</code>. There is also a version of this variant of the operator that
          takes an <code>IScheduler</code> as a parameter and uses it to govern the timespan.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/Buffer7.net.png" width="640" height="320" alt="Buffer(timeSpan,timeShift)" />
      <figcaption>
       <p><code>Buffer(timeSpan,&#8239;timeShift)</code> creates a new <code>IList</code> of items
          every <code>timeShift</code> period of time, and fills this list with every item emitted
          by the source Observable from that time until <code>timeSpan</code> time has passed since
          the list&#8217;s creation, before emitting this <code>IList</code> as its own emission. If
          <code>timeSpan</code> is longer than <code>timeShift</code>, the emitted lists will
          represent time periods that overlap and so they may contain duplicate items. There is also
          a version of this variant of the operator that takes an <code>IScheduler</code> as a
          parameter and uses it to govern the timespan.</p>
      </figcaption>
     </figure>
    </div>

<!-- RxPY ===================================================================================== -->
    <h3>RxPY</h3><div id="RxPY">
     <p>
      RxPY has several <span class="operator">Buffer</span> variants: <code>buffer</code>,
      <code>buffer_with_count</code>, <code>buffer_with_time</code>, and
      <code>buffer_with_time_or_count</code>. For each of these variants there are optional
      parameters that change the behavior of the operator. As always in RxPY, when an operator may
      take more than one optional parameter, be sure to name the parameter in the parameter list
      when you call the operator so as to avoid ambiguity.
     </p>
     <figure class="variant">
      <img src="IMAGES/buffer8.py.png" width="640" height="390" alt="buffer(buffer_openings)" />
      <figcaption>
       <p><code>buffer(buffer_openings=boundaryObservable)</code> monitors an Observable,
          <code>buffer_openings</code>. Each time that Observable emits an item, it creates a new
          array to begin collecting items emitted by the source Observable and emits the
          previous array.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer1.py.png" width="640" height="395" alt="buffer(closing_selector)" />
      <figcaption>
       <p><code>buffer(closing_selector=closingSelector)</code> begins collecting items emitted
          by the source Observable immediately upon subscription, and also calls the
          <code>closing_selector</code> function to generate a second Observable. It monitors this
          new Observable and, when it completes or emits an item, it emits the current array,
          begins a new array to collect items from the source Observable, and calls
          <code>closing_selector</code> again to generate a new Observable to monitor in order to
          determine when to emit the new array. It repeats this process until the source Observable
          terminates, whereupon it emits the final array.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer2.py.png" width="640" height="470" alt="buffer(closing_selector,buffer_closing_selector)" />
      <figcaption>
       <p><code>buffer(closing_selector=openingSelector,&nbsp;buffer_closing_selector=closingSelector)</code>
       begins by calling <code>closing_selector</code> to get an Observable. It monitors this
       Observable, and, whenever it emits an item, <code>buffer</code> creates a new array, begins
       to collect items subsequently emitted by the source Observable into this array, and calls
       <code>buffer_closing_selector</code> to get a new Observable to govern the closing of that
       array. When this new Observable emits an item or terminates, <code>buffer</code> closes and
       emits the array that the Observable governs.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer_with_count3.py.png" width="640" height="320" alt="buffer_with_count(count)" />
      <figcaption>
       <p><code>buffer_with_count(count)</code> emits non-overlapping buffers in the form of
          arrays, each of which contains at most <code>count</code> items from the source Observable
          (the final emitted array may have fewer than <code>count</code> items).</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer_with_count4.py.png" width="640" height="320" alt="buffer_with_count(count,skip)" />
      <figcaption>
       <p><code>buffer_with_count(count,&#8239;skip=skip)</code> creates a new buffer starting with
          the first emitted item from the source Observable, and every <code>skip</code> items
          thereafter, and fills each buffer with <code>count</code> items: the initial item and
          <code>count-1</code> subsequent ones. It emits these buffers as arrays. Depending on the
          values of <code>count</code> and <code>skip</code> these buffers may overlap (multiple
          buffers may contain the same item), or they may have gaps (where items emitted by the
          source Observable are not represented in any buffer).</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer_with_time5.py.png" width="640" height="320" alt="buffer_with_time(timespan)" />
      <figcaption>
       <p><code>buffer_with_time(timespan)</code> emits a new array of items periodically, every
          <code>timespan</code> milliseconds, containing all items emitted by the source Observable
          since the previous bundle emission or, in the case of the first bundle, since the
          subscription to the source Observable. There is also a version of this variant of the
          operator that takes a <code>scheduler</code> parameter and uses it to govern the timespan;
          by default this variant uses the <code>timeout</code> scheduler.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer_with_time7.py.png" width="640" height="350" alt="buffer_with_time(timespan,timeshift)" />
      <figcaption>
       <p><code>buffer(timespan,&#8239;timeshift=timeshift)</code> creates a new array of items
          every <code>timeshift</code> milliseconds, and fills this array with every item emitted
          by the source Observable from that time until <code>timespan</code> milliseconds have
          passed since the array&#8217;s creation, before emitting this array as its own emission.
          If <code>timespan</code> is longer than <code>timeshift</code>, the emitted arrays will
          represent time periods that overlap and so they may contain duplicate items. There is also
          a version of this variant of the operator that takes a <code>scheduler</code> parameter
          and uses it to govern the timespan; by default this variant uses the <code>timeout</code>
          scheduler.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer_with_time_or_count6.py.png" width="640" height="320" alt="buffer_with_time_or_count(timespan,count)" />
      <figcaption>
       <p><code>buffer_with_time_or_count(timespan,&#8239;count)</code> emits a new array of items
          for every <code>count</code> items emitted by the source Observable, or, if
          <code>timespan</code> milliseconds have elapsed since its last bundle emission, it emits
          an array of however many items the source Observable has emitted in that span, even if
          this is fewer than <code>count</code>. There is also a version of this variant of the
          operator that takes a <code>scheduler</code> parameter and uses it to govern the timespan;
          by default this variant uses the <code>timeout</code> scheduler.</p>
      </figcaption>
     </figure>
    </div>

<!-- Rx.rb ==================================================================================== -->
    <h3>Rx.rb</h3><div id="Rxrb">
     <p>
      Rx.rb has three variants of the <span class="operator">Buffer</span> operator:
     </p>
     <figure class="variant">
      <img src="IMAGES/buffer_with_count3.py.png" width="640" height="320" alt="buffer_with_count(count)" />
      <figcaption>
       <p><code>buffer_with_count(count)</code> emits non-overlapping buffers in the form of
          arrays, each of which contains at most <code>count</code> items from the source Observable
          (the final emitted array may have fewer than <code>count</code> items).</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer_with_count4.rb.png" width="640" height="320" alt="buffer_with_count(count,skip)" />
      <figcaption>
       <p><code>buffer_with_count(count,&#8239;skip=skip)</code> creates a new buffer starting with
          the first emitted item from the source Observable, and every <code>skip</code> items
          thereafter, and fills each buffer with <code>count</code> items: the initial item and
          <code>count-1</code> subsequent ones. It emits these buffers as arrays. Depending on the
          values of <code>count</code> and <code>skip</code> these buffers may overlap (multiple
          buffers may contain the same item), or they may have gaps (where items emitted by the
          source Observable are not represented in any buffer).</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/buffer_with_time5.py.png" width="640" height="320" alt="buffer_with_time(timespan)" />
      <figcaption>
       <p><code>buffer_with_time(timespan)</code> emits a new array of items periodically, every
          <code>timespan</code> milliseconds, containing all items emitted by the source Observable
          since the previous bundle emission or, in the case of the first bundle, since the
          subscription to the source Observable.</p>
      </figcaption>
     </figure>
    </div>

<!-- RxScala ================================================================================== -->
    <h3>RxScala</h3><div id="RxScala">
     <p>
      RxScala has two varieties of <span class="operator">Buffer</span> &mdash;
      <code>slidingBuffer</code> and <code>tumblingBuffer</code> &mdash; each of which has variants
      with different ways of assembling the buffers they emit:
     </p>
     <figure class="variant">
      <img src="IMAGES/slidingBuffer4.png" width="640" height="320" alt="slidingBuffer(count,skip)" />
      <figcaption>
       <p><code>slidingBuffer(count,&#8239;skip)</code> creates a new buffer starting with the first
          emitted item from the source Observable, and every <code>skip</code> items thereafter, and
          fills each buffer with <code>count</code> items: the initial item and <code>count-1</code>
          subsequent ones. It emits these buffers as <code>Seq</code>s. Depending on the values of
          <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may
          contain the same item), or they may have gaps (where items emitted by the source
          Observable are not represented in any buffer).</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/slidingBuffer7.png" width="640" height="350" alt="slidingBuffer(timespan,timeshift)" />
      <figcaption>
       <p><code>slidingBuffer(timespan,&#8239;timeshift)</code> creates a new
          <code>Seq</code> of items every <code>timeshift</code> (a <code>Duration</code>), and
          fills this buffer with every item emitted by the source Observable from that time until
          <code>timespan</code> (also a <code>Duration</code>) has passed since the buffer&#8217;s
          creation, before emitting this <code>Seq</code> as its own emission. If
          <code>timespan</code> is longer than <code>timeshift</code>, the emitted arrays will
          represent time periods that overlap and so they may contain duplicate items. There is also
          a version of this variant of the operator that takes a <code>Scheduler</code> as a
          parameter and uses it to govern the timespan.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/slidingBuffer2.png" width="640" height="470" alt="slidingBuffer(openings,closings)" />
      <figcaption>
       <p><code>slidingBuffer(openings,closings)</code> monitors the <code>openings</code>
       Observable, and, whenever it emits an <code>Opening</code> item, <code>slidingBuffer</code>
       creates a new <code>Seq</code>, begins to collect items subsequently emitted by the source
       Observable into this buffer, and calls <code>closings</code> to get a new Observable to
       govern the closing of that buffer. When this new Observable emits an item or terminates,
       <code>slidingBuffer</code> closes and emits the <code>Seq</code>that the Observable
       governs.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/tumblingBuffer3.png" width="640" height="320" alt="tumblingBuffer(count)" />
      <figcaption>
       <p><code>tumblingBuffer(count)</code> emits non-overlapping buffers in the form of
          <code>Seq</code>s, each of which contains at most <code>count</code> items from the source
          Observable (the final emitted buffer may have fewer than <code>count</code> items).</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/tumblingBuffer8.png" width="640" height="390" alt="tumblingBuffer(boundary)" />
      <figcaption>
       <p><code>tumblingBuffer(boundary)</code> monitors an Observable, <code>boundary</code>. Each
          time that Observable emits an item, it creates a new <code>Seq</code> to begin collecting
          items emitted by the source Observable and emits the previous <code>Seq</code>. This
          variant of the operator has an optional second parameter, <code>initialCapacity</code>
          with which you can indicate the expected size of these buffers so as to make memory
          allocation more efficient.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/tumblingBuffer5.png" width="640" height="320" alt="tumblingBuffer(timespan)" />
      <figcaption>
       <p><code>tumblingBuffer(timespan)</code> emits a new <code>Seq</code> of items periodically,
          every <code>timespan</code> (a <code>Duration</code>), containing all items emitted by the
          source Observable since the previous bundle emission or, in the case of the first bundle,
          since the subscription to the source Observable. This variant of the operator has an
          optional second parameter, <code>scheduler</code>, with which you can set the
          <code>Scheduler</code> that you want to govern the timespan calculation.</p>
      </figcaption>
     </figure>
     <figure class="variant">
      <img src="IMAGES/tumblingBuffer6.png" width="640" height="320" alt="tumblingBuffer(timespan,count)" />
      <figcaption>
       <p><code>tumblingBuffer(timespan,&#8239;count)</code> emits a new <code>Seq</code> of items
          for every <code>count</code> items emitted by the source Observable, or, if
          <code>timespan</code> (a <code>Duration</code>) has elapsed since its last bundle
          emission, it emits a <code>Seq</code> containing however many items the source Observable
          emitted in that span, even if this is fewer than <code>count</code>. This variant of the
          operator has an optional third parameter, <code>scheduler</code>, with which you can set
          the <code>Scheduler</code> that you want to govern the timespan calculation.</p>
      </figcaption>
     </figure>
<!--
     tumblingBuffer(timespan, count[, scheduler])      buffer6
-->
    </div>

   </div>
  </div>

 <script src="JS/jquery-1.11.1.min.js"></script>
 <script src="jquery-ui-1.11.2.custom/jquery-ui.js"></script>
 <script>
  $("#accordion").accordion({ collapsible: true, active: false, heightStyle: "content" });
 </script>
 </body>
</html>
